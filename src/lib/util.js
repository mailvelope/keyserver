/**
 * Copyright (C) 2020 Mailvelope GmbH
 * Licensed under the GNU Affero General Public License version 3
 */

'use strict';

const crypto = require('crypto');

/**
 * Checks for a valid string
 * @param  {} data     The input to be checked
 * @return {boolean}   If data is a string
 */
exports.isString = function(data) {
  return typeof data === 'string' || String.prototype.isPrototypeOf(data); // eslint-disable-line no-prototype-builtins
};

/**
 * Parse string into number
 * @param  {String} number
 * @return {Number|undefined}
 */
exports.parseNumber = function(number) {
  const integer = parseInt(number);
  return isNaN(integer) ? undefined : integer;
};

/**
 * Cast string to a boolean value
 * @param  {}  data    The input to be checked
 * @return {boolean}   If data is true
 */
exports.isTrue = function(data) {
  if (this.isString(data)) {
    return data === 'true';
  } else {
    return Boolean(data);
  }
};

/**
 * Checks for a valid long key id which is 16 hex chars long.
 * @param  {string} data   The key id
 * @return {boolean}       If the key id is valid
 */
exports.isKeyId = function(data) {
  if (!this.isString(data)) {
    return false;
  }
  return /^[a-fA-F0-9]{16}$/.test(data);
};

/**
 * Checks for a valid version 4 fingerprint which is 40 hex chars long.
 * @param  {string} data   The key id
 * @return {boolean}       If the fingerprint is valid
 */
exports.isFingerPrint = function(data) {
  if (!this.isString(data)) {
    return false;
  }
  return /^[a-fA-F0-9]{40}$/.test(data);
};

/**
 * Checks for a valid email address.
 * @param  {string} data   The email address
 * @return {boolean}       If the email address if valid
 */
exports.isEmail = function(data) {
  if (!this.isString(data)) {
    return false;
  }
  const re = /^[+a-zA-Z0-9_.!#$%&'*\/=?^`{|}~-]+@([a-zA-Z0-9-]+\.)+[a-zA-Z0-9]{2,63}$/;
  return re.test(data);
};

/**
 * Checks for a valid nonce.
 * @param  {string} data   The nonce
 * @return {boolean}       If the nonce is valid
 */
exports.isNonce = function(data) {
  return this.isString(data) && data.length === 32;
};

/**
 * Normalize email address to lowercase.
 * @param  {string} email   The email address
 * @return {string}       lowercase email address
 */
exports.normalizeEmail = function(email) {
  if (email) {
    email = email.toLowerCase();
  }
  return email;
};

/**
 * Generate a cryptographically secure random hex string. If no length is
 * provided a 32 char hex string will be generated by default.
 * @param  {number} bytes   (optional) The number of random bytes
 * @return {string}         The random bytes in hex (twice as long as bytes)
 */
exports.random = function(bytes = 16) {
  return crypto.randomBytes(bytes).toString('hex');
};

/**
 * Check if the user is connecting over a plaintext http connection.
 * This can be used as an indicator to upgrade their connection to https.
 * @param  {Object} request - hapi request object
 * @return {boolean}      If http is used
 */
exports.checkHTTP = function(request) {
  return request.server.info.protocol === 'http' && request.headers['x-forwarded-proto'] === 'http';
};

/**
 * Check if the user is connecting over a https connection.
 * @param  {Object} request - hapi request object
 * @return {boolean}      If https is used
 */
exports.checkHTTPS = function(request) {
  return request.server.info.protocol === 'https' || request.headers['x-forwarded-proto'] === 'https';
};

/**
 * Get the server's own origin host and protocol. Required for sending
 * verification links via email. If the PORT environmane variable
 * is set, we assume the protocol to be 'https', since the AWS loadbalancer
 * speaks 'https' externally but 'http' between the LB and the server.
 * @param  {Object} request - hapi request object
 * @return {Object}       The server origin
 */
exports.origin = function(request) {
  return {
    protocol: this.checkHTTPS(request) ? 'https' : request.server.info.protocol,
    host: request.info.host
  };
};

/**
 * Helper to create urls pointing to this server
 * @param  {Object} origin     The server's origin
 * @param  {string} resource   (optional) The resource to point to
 * @return {string}            The complete url
 */
exports.url = function(origin, resource) {
  return `${origin.protocol}://${origin.host}${resource || ''}`;
};

/**
 * Validity status of a key
 * @type {Object}
 */
exports.KEY_STATUS = {
  invalid: 0,
  expired: 1,
  revoked: 2,
  valid: 3,
  no_self_cert: 4
};

/**
 * Asynchronous wrapper for Array.prototype.filter()
 * @param  {Array} array
 * @param  {Function} asyncFilterFn
 * @return {Promise<Array>}
 */
exports.filterAsync = async function(array, asyncFilterFn) {
  const promises = array.map(async item => await asyncFilterFn(item) && item);
  const result = await Promise.all(promises);
  return result.filter(item => item);
};

/**
 * Return Date one day in the future
 * @return {Date}
 */
exports.getTomorrow = function() {
  const now = new Date();
  now.setDate(now.getDate() + 1);
  return now;
};
