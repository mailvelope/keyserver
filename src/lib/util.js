/**
 * Copyright (C) 2020 Mailvelope GmbH
 * Licensed under the GNU Affero General Public License version 3
 *
 * genWKDHash and encodeZBase32 are based on wkd-client node module,
 * which is WKD client implementation in javascript
 * Copyright (C) 2018 Wiktor Kwapisiewicz
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.0 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 * USA
 */

'use strict';

const crypto = require('crypto');

/**
 * Checks for a valid string
 * @param  {} data     The input to be checked
 * @return {boolean}   If data is a string
 */
exports.isString = function(data) {
  return typeof data === 'string' || String.prototype.isPrototypeOf(data); // eslint-disable-line no-prototype-builtins
};

/**
 * Parse string into number
 * @param  {String} number
 * @return {Number|undefined}
 */
exports.parseNumber = function(number) {
  const integer = parseInt(number);
  return isNaN(integer) ? undefined : integer;
};

/**
 * Cast string to a boolean value
 * @param  {}  data    The input to be checked
 * @return {boolean}   If data is true
 */
exports.isTrue = function(data) {
  if (this.isString(data)) {
    return data === 'true';
  } else {
    return Boolean(data);
  }
};

/**
 * Checks for a valid long key id which is 16 hex chars long.
 * @param  {string} data   The key id
 * @return {boolean}       If the key id is valid
 */
exports.isKeyId = function(data) {
  if (!this.isString(data)) {
    return false;
  }
  return /^[a-fA-F0-9]{16}$/.test(data);
};

/**
 * Checks for a valid version 4 fingerprint which is 40 hex chars long.
 * @param  {string} data   The key id
 * @return {boolean}       If the fingerprint is valid
 */
exports.isFingerPrint = function(data) {
  if (!this.isString(data)) {
    return false;
  }
  return /^[a-fA-F0-9]{40}$/.test(data);
};

/**
 * Checks for a valid email address.
 * @param  {string} data   The email address
 * @return {boolean}       If the email address if valid
 */
exports.isEmail = function(data) {
  if (!this.isString(data)) {
    return false;
  }
  const re = /^[+a-zA-Z0-9_.!#$%&'*\/=?^`{|}~-]+@([a-zA-Z0-9-]+\.)+[a-zA-Z0-9]{2,63}$/;
  return re.test(data);
};

/**
 * Checks for a valid nonce.
 * @param  {string} data   The nonce
 * @return {boolean}       If the nonce is valid
 */
exports.isNonce = function(data) {
  return this.isString(data) && data.length === 32;
};

/**
 * Normalize email address to lowercase.
 * @param  {string} email   The email address
 * @return {string}       lowercase email address
 */
exports.normalizeEmail = function(email) {
  if (email) {
    email = email.toLowerCase();
  }
  return email;
};

exports.genWKDHash = function(email) {
 return new Promise((resolve, reject) => {
    const [localPart, domain] = email.split('@');
    const localPartHashed = crypto.createHash('sha1')
      .update(localPart.toLowerCase())
      .digest();
    const localPartBase32 = encodeZBase32(localPartHashed);
    const wkdhash = localPartBase32 + '@' + domain;
    resolve(wkdhash);
  });
}

function encodeZBase32(data) {
  if (data.length === 0) {
    return "";
  }
  const ALPHABET = "ybndrfg8ejkmcpqxot1uwisza345h769";
  const SHIFT = 5;
  const MASK = 31;
  let buffer = data[0];
  let index = 1;
  let bitsLeft = 8;
  let result = '';
  while (bitsLeft > 0 || index < data.length) {
    if (bitsLeft < SHIFT) {
      if (index < data.length) {
        buffer <<= 8;
        buffer |= data[index++] & 0xff;
        bitsLeft += 8;
      } else {
        const pad = SHIFT - bitsLeft;
        buffer <<= pad;
        bitsLeft += pad;
      }
    }
    bitsLeft -= SHIFT;
    result += ALPHABET[MASK & (buffer >> bitsLeft)];
  }
  return result;
}

/**
 * Generate a cryptographically secure random hex string. If no length is
 * provided a 32 char hex string will be generated by default.
 * @param  {number} bytes   (optional) The number of random bytes
 * @return {string}         The random bytes in hex (twice as long as bytes)
 */
exports.random = function(bytes = 16) {
  return crypto.randomBytes(bytes).toString('hex');
};

/**
 * Check if the user is connecting over a plaintext http connection.
 * This can be used as an indicator to upgrade their connection to https.
 * @param  {Object} request - hapi request object
 * @return {boolean}      If http is used
 */
exports.checkHTTP = function(request) {
  return request.server.info.protocol === 'http' && request.headers['x-forwarded-proto'] === 'http';
};

/**
 * Check if the user is connecting over a https connection.
 * @param  {Object} request - hapi request object
 * @return {boolean}      If https is used
 */
exports.checkHTTPS = function(request) {
  return request.server.info.protocol === 'https' || request.headers['x-forwarded-proto'] === 'https';
};

/**
 * Get the server's own origin host and protocol. Required for sending
 * verification links via email. If the PORT environmane variable
 * is set, we assume the protocol to be 'https', since the AWS loadbalancer
 * speaks 'https' externally but 'http' between the LB and the server.
 * @param  {Object} request - hapi request object
 * @return {Object}       The server origin
 */
exports.origin = function(request) {
  return {
    protocol: this.checkHTTPS(request) ? 'https' : request.server.info.protocol,
    host: request.info.host
  };
};

/**
 * Helper to create urls pointing to this server
 * @param  {Object} origin     The server's origin
 * @param  {string} resource   (optional) The resource to point to
 * @return {string}            The complete url
 */
exports.url = function(origin, resource) {
  return `${origin.protocol}://${origin.host}${resource || ''}`;
};

/**
 * Validity status of a key
 * @type {Object}
 */
exports.KEY_STATUS = {
  invalid: 0,
  expired: 1,
  revoked: 2,
  valid: 3,
  no_self_cert: 4
};

/**
 * Asynchronous wrapper for Array.prototype.filter()
 * @param  {Array} array
 * @param  {Function} asyncFilterFn
 * @return {Promise<Array>}
 */
exports.filterAsync = async function(array, asyncFilterFn) {
  const promises = array.map(async item => await asyncFilterFn(item) && item);
  const result = await Promise.all(promises);
  return result.filter(item => item);
};

/**
 * Return Date one day in the future
 * @return {Date}
 */
exports.getTomorrow = function() {
  const now = new Date();
  now.setDate(now.getDate() + 1);
  return now;
};
